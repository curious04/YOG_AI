function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);

var createContext = function createContext() {
  var Context = React__default.createContext(undefined);

  var useContext = function useContext() {
    var value = React__default.useContext(Context);
    if (value === undefined) throw new Error('useContext must be used within a Provider with a value');
    return value;
  };

  return [useContext, Context.Provider];
};

var isClient = typeof window === 'object';
var useLocalStorage = function useLocalStorage(key, initialValue) {
  var _useState = React.useState(function () {
    if (!isClient) {
      return undefined;
    }

    try {
      var localStorageValue = window.localStorage.getItem(key);
      return localStorageValue === null ? initialValue : JSON.parse(localStorageValue);
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  }),
      storedValue = _useState[0],
      setStoredValue = _useState[1];

  React.useEffect(function () {
    try {
      window.localStorage.setItem(key, JSON.stringify(storedValue));
    } catch (error) {
      console.error(error);
    }
  }, [storedValue]);
  return [storedValue, setStoredValue];
};

var _createContext = createContext(),
    useOnboard = _createContext[0],
    OnboardContextProvider = _createContext[1];

var useOnboardProvider = function useOnboardProvider(messages, showCallback, ackCallback, HighlightComponent) {
  var _useLocalStorage = useLocalStorage("messagesAcked", []),
      messagesAcked = _useLocalStorage[0],
      setMessagesAcked = _useLocalStorage[1];

  var _useState = React.useState([]),
      renderedElements = _useState[0],
      setRenderedElements = _useState[1];

  var _useState2 = React.useState(null),
      activeMessage = _useState2[0],
      setActiveMessage = _useState2[1];

  var ackMessage = function ackMessage(id) {
    if (id !== undefined && id !== null && !messagesAcked.includes(id)) {
      setMessagesAcked([].concat(messagesAcked, [id]));
      return true;
    }

    return false;
  };

  React.useEffect(function () {
    if (activeMessage !== null && activeMessage.id === messagesAcked[messagesAcked.length - 1]) {
      ackCallback({
        messageId: activeMessage.id
      });
      setActiveMessage(null);
    }
  }, [messagesAcked]);
  React.useEffect(function () {
    var didCancel = false;

    if (activeMessage === null && !didCancel) {
      messages.filter(function (_ref) {
        var id = _ref.id;
        return !messagesAcked.includes(id);
      }).some(function (_ref2) {
        var id = _ref2.id,
            children = _ref2.children,
            elementIds = _ref2.elementIds,
            delay = _ref2.delay;
        var unrenderedElements = elementIds === null || elementIds === void 0 ? void 0 : elementIds.filter(function (elementId) {
          return !renderedElements.includes(elementId);
        });

        if (unrenderedElements === undefined || unrenderedElements.length === 0) {
          setTimeout(function () {
            return setActiveMessage({
              id: id,
              elementIds: elementIds,
              children: children
            });
          }, delay != null ? delay : 0);
          return true;
        }

        return false;
      });
    }

    return function () {
      didCancel = true;
    };
  }, [activeMessage, renderedElements]);
  React.useEffect(function () {
    if (activeMessage !== null) {
      showCallback({
        messageId: activeMessage.id,
        children: activeMessage.children,
        onAck: function onAck() {
          return ackMessage(activeMessage.id);
        }
      });
    }
  }, [activeMessage]);
  return {
    activeMessage: activeMessage,
    onElementRender: function onElementRender(elementId) {
      if (!renderedElements.includes(elementId)) {
        setRenderedElements(function (elements) {
          return [].concat(elements, [elementId]);
        });
      }
    },
    onElementUnrender: function onElementUnrender(elementId) {
      setRenderedElements(function (elements) {
        return elements.filter(function (element) {
          return element !== elementId;
        });
      });
    },
    ackMessage: ackMessage,
    HighlightComponent: HighlightComponent
  };
};

var OnboardProvider = function OnboardProvider(_ref3) {
  var children = _ref3.children,
      messages = _ref3.messages,
      showCallback = _ref3.showCallback,
      ackCallback = _ref3.ackCallback,
      HighlightComponent = _ref3.HighlightComponent;
  var value = useOnboardProvider(messages, showCallback, ackCallback, HighlightComponent);
  return React__default.createElement(OnboardContextProvider, {
    value: value
  }, children);
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var OnboardElement = function OnboardElement(_ref) {
  var id = _ref.id,
      children = _ref.children,
      _ref$ackOnClick = _ref.ackOnClick,
      ackOnClick = _ref$ackOnClick === void 0 ? true : _ref$ackOnClick,
      _ref$ackOnMouseOver = _ref.ackOnMouseOver,
      ackOnMouseOver = _ref$ackOnMouseOver === void 0 ? 1000 : _ref$ackOnMouseOver;

  var _useState = React.useState(false),
      isActive = _useState[0],
      setIsActive = _useState[1];

  var _useOnboard = useOnboard(),
      onElementRender = _useOnboard.onElementRender,
      onElementUnrender = _useOnboard.onElementUnrender,
      activeMessage = _useOnboard.activeMessage,
      ackMessage = _useOnboard.ackMessage,
      HighlightComponent = _useOnboard.HighlightComponent;

  React.useEffect(function () {
    onElementRender(id);
    return function () {
      return onElementUnrender(id);
    };
  }, []);
  React.useEffect(function () {
    var _activeMessage$elemen;

    setIsActive(Boolean(activeMessage === null || activeMessage === void 0 ? void 0 : (_activeMessage$elemen = activeMessage.elementIds) === null || _activeMessage$elemen === void 0 ? void 0 : _activeMessage$elemen.includes(id)));
    return function () {
      return setIsActive(false);
    };
  }, [activeMessage]);

  var dismiss = function dismiss() {
    if (isActive) ackMessage(activeMessage.id);
  };

  var _useState2 = React.useState(),
      dismissTimeout = _useState2[0],
      setDismissTimeout = _useState2[1];

  var newChildren = React.cloneElement(children, _extends({}, children.props, {
    style: _extends({
      visibility: 'initial'
    }, children.props.style)
  }));
  return React__default.createElement(HighlightComponent, {
    onClick: function onClick() {
      if (ackOnClick) {
        dismiss();
        window.clearTimeout(dismissTimeout);
        setDismissTimeout(undefined);
      }
    },
    onMouseOver: function onMouseOver() {
      if (ackOnMouseOver > 0 && dismissTimeout === undefined) setDismissTimeout(window.setTimeout(dismiss, ackOnMouseOver));
    },
    onMouseLeave: function onMouseLeave() {
      if (ackOnMouseOver > 0) {
        window.clearTimeout(dismissTimeout);
        setDismissTimeout(undefined);
      }
    },
    style: {
      visibility: isActive ? 'initial' : 'hidden'
    }
  }, newChildren);
};

exports.OnboardElement = OnboardElement;
exports.OnboardProvider = OnboardProvider;
//# sourceMappingURL=index.js.map
